# TODO-workflow

It's hard to follow scenes around. Particularly because some of the scenes are rather small (e.g. simply to define a condition to send it to the next scene).

For a series of activities and conversations that could be rolled up into one situation it would probably be more idea to capture that in a single scene. The problem is the current structure of how we define the scenes and this gets me back to the idea of building:

A parser that looks at each write, transition, option, and condition as an event added to a stream of events that make up the scene. Then each one of these events will pop off the stack.

* Writes will output content for their event. A write event can be assigned an `id` otherwise a default `id` will be generated for it.

* `option` define the details of the option. Each option's block has a scene description which is another series of events. When an option is defined it is added to a list of `existing_options`. A `choice` event will review the list of `existing_option` and then present them to the player. The player will select an `option`. The `option`'s scene description block will be evaluated and the events defined in the scene description will be added to the top of the event queue. However, the results of the `option` may want to effect something later in the event queue, so you can specify if you want to `before: 'event-id'` or `after: 'event-id'`. TODO: What do we do if we have events with the same id

* `choice` is a new scene term. Because `option` do not make a player choose a new term would need to be introduced. At that moment all choices in the queue would be displayed. When a choice has been made, all choices in the queue are removed (unless otherwise stated). A choice will select the `option`. The option will have its scene description be evaluated and those items would by default be added to the event queue.

* `transition` would load a scene definition and insert those events on the top of the event queue. I imagine you could define a large over-arching scene. This scene would then tell the story from the beginning to end. When you want to add a sub-story (e.g. the removing of termites, that would be on a story defined in a transition). Those events being loaded would be loaded and executed. But there is no reason to unload the original details. Think of the transition as an include. Think of the items within the event stream as a resource collection. Some validation could be performed ahead of time which is nice (e.g. transitions that go nowhere)

* `condition` are now transitioning to be bash tests that are written to a bash file that is run after every command the player executes while on the system. So in an event stream view conditions would need to be added and removed fairly easily. Which could be done with a directory of active conditions and an the time present script is scanning that directory and then executing on any that it finds. `condition` is also currently putting the player back in during a particular scene. So `condition` would need to now support add or remove.

* `shell` is a new scene term that sends the player to the terminal world. This is where they are able to enter commands into the system. By adding this term we can create an event instead of relying on the scenes not transitioning as they were before. Starting a shell starts an interactive session with the system. The shell will want to check for active conditions. When no active conditions are met the player is able to enter any command. When an active condition is met the condition script will return the player to the game engine.

* `fake_shell` is the idea that when the user goes to solve problems with the shell, we actually don't give them a real shell. We essentially proxy all the commands to the shell for them. The benefit is that we could provide some more feedback on what went wrong. Stop them from using other non-prescribed commands. It also has the benefit of allowing some format control and event stream things when telling the stories. There is a performance benefit as the execution remains in memory, the conditions are already loaded and can be easily managed. The remaining work is to bring in the verification libraries and potentially more tightly integrate them. So within the condition itself you could write the inspec code that will verify the system.

* `real_shell` is ultimately where we would want to go and I think there is a place for it as well. If we were to use a real shell we would leave the game engine and that would require some amount of state saving. The game itself could write out its entire event queue. It could save the id of the event where it left to the real_shell. When the game returns it loads the entire event queue and would likely need to re-play the choices that the player made to ensure the proper event queue was built. A limitation of the game is that when you come to a real_shell moment you need to have the game in a simple state with no conditional events specified. Getting back into the game could be done through a specific command like I did in the first prototype. To make this work it seems like you would need to define the event watcher to look at the game world and run as a service. All file events on the game world would then generate events added to an event queue. The event queue would then be watched by some additional service that is currently running all the current game conditions. If the conditionals were met and the player needed to return to the game world could we force them to tell more story? Could we update a field in the prompt or world view that would cause them to want to come back? The conditions service could then send them a message directly or indirectly through the same message queue. The players system checks for messages constantly through some service. When this program, run after each command, finds a message it will display it to them. This message could also force a script to run and the game to return.
